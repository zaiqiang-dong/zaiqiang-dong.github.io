import{_ as h,r as a,o as l,c as r,a as o,d as t,e as d,b as i,w as p}from"./app.21cc2de4.js";const m="/blog/assets/2021-05-26_15-54.a54368ba.png",u="/blog/assets/addr-yimaqi.d018c582.png",v=JSON.parse('{"title":"简介","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 硬件的样子","slug":"_1-硬件的样子","link":"#_1-硬件的样子","children":[]},{"level":2,"title":"2. 地址空间的形成","slug":"_2-地址空间的形成","link":"#_2-地址空间的形成","children":[]},{"level":2,"title":"3. 编址方式","slug":"_3-编址方式","link":"#_3-编址方式","children":[{"level":3,"title":"3.1 统一编址","slug":"_3-1-统一编址","link":"#_3-1-统一编址","children":[]},{"level":3,"title":"3.2 独立编址","slug":"_3-2-独立编址","link":"#_3-2-独立编址","children":[]}]},{"level":2,"title":"4. 地址空间的划分","slug":"_4-地址空间的划分","link":"#_4-地址空间的划分","children":[{"level":3,"title":"4.1 通过硬连线来划分","slug":"_4-1-通过硬连线来划分","link":"#_4-1-通过硬连线来划分","children":[]},{"level":3,"title":"4.2 通过软件来划分","slug":"_4-2-通过软件来划分","link":"#_4-2-通过软件来划分","children":[]}]},{"level":2,"title":"5. 小结","slug":"_5-小结","link":"#_5-小结","children":[]}],"relativePath":"hardware/addressSpace/common/intro/intro.md"}'),Q={name:"hardware/addressSpace/common/intro/intro.md"},T={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},g={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.186ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.242ex",height:"2.072ex",role:"img",focusable:"false",viewBox:"0 -833.9 2759 915.9","aria-hidden":"true"};function x(n,e,b,_,f,w){const s=a("mjx-assistive-mml"),c=a("Vssue");return l(),r("div",null,[e[14]||(e[14]=o('<h1 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-hidden="true">#</a></h1><hr><table><thead><tr><th>软件版本</th><th>硬件版本</th><th>更新内容</th></tr></thead><tbody><tr><td>linux 5.8.18</td><td></td><td></td></tr></tbody></table><hr><h2 id="_1-硬件的样子" tabindex="-1">1. 硬件的样子 <a class="header-anchor" href="#_1-硬件的样子" aria-hidden="true">#</a></h2><p><img src="'+m+'" alt="addr-bus" title="addr-bus"> 如上图所示，地址总线一般从<code>CPU</code>的引脚发出，连接到一些外围设备，这里一定的注意的是，地址总线上挂载的不只有内存，任何一个可以被<code>CPU</code>直接寻址的设备都会挂载到<code>CPU</code>的地址总线上，比如X86平台显卡设备，PCI设备，再比如ARM平台的片上外围器件，如<code>I2C</code>控制器等。</p><h2 id="_2-地址空间的形成" tabindex="-1">2. 地址空间的形成 <a class="header-anchor" href="#_2-地址空间的形成" aria-hidden="true">#</a></h2>',7)),t("p",null,[e[2]||(e[2]=d("如果你有数字逻辑电路的知识，应该很好理解地址的形成,如下图所示： ")),e[3]||(e[3]=t("img",{src:u,alt:"add-yimaqi",title:"yimaqi"},null,-1)),e[4]||(e[4]=d(" 上图是一个简易的存储器芯片的译码器部分，这个存储器可以存储4个字节的数据,那个需要的地址线就是两根")),e[5]||(e[5]=t("code",null,"A0",-1)),e[6]||(e[6]=d(",")),e[7]||(e[7]=t("code",null,"A1",-1)),e[8]||(e[8]=d(",原因也很好理解，每个根地址线可以有两种状态，高电平和低电平，对应表示")),e[9]||(e[9]=t("code",null,"0",-1)),e[10]||(e[10]=d("，")),e[11]||(e[11]=t("code",null,"1",-1)),e[12]||(e[12]=d(",那个两根地址线组合之后会有4种状态，所以可以选择读取或者写入4个字节的数据。 从上面的这个简易的存储器我们就可以得到地址空间的概念，也就是所有的地址线的排列组合，也就从0到")),t("mjx-container",T,[(l(),r("svg",g,e[0]||(e[0]=[o('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" style="stroke-width:3;"></path></g></g><g data-mml-node="mo" transform="translate(1258.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(2259,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" style="stroke-width:3;"></path></g></g></g>',1)]))),i(s,{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},{default:p(()=>e[1]||(e[1]=[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("msup",null,[t("mi",null,"n"),t("mn",null,"2")]),t("mo",null,"−"),t("mn",null,"1")],-1)])),_:1})]),e[13]||(e[13]=d("。这个空间和外围挂载多少设备，什么样的设备没有任何关系，它就是一个CPU可以寻址的范围。"))]),e[15]||(e[15]=o('<h2 id="_3-编址方式" tabindex="-1">3. 编址方式 <a class="header-anchor" href="#_3-编址方式" aria-hidden="true">#</a></h2><h3 id="_3-1-统一编址" tabindex="-1">3.1 统一编址 <a class="header-anchor" href="#_3-1-统一编址" aria-hidden="true">#</a></h3><p>每一种编址方式就是统一编址，也就是所有的设备共享同一个地址空间，典型的就是<code>ARM</code>平台。 统一编址的情况IO端口数目不受限制，而且CPU也无需产生存储器或者IO操作的控制信号，但同时 引入的问题就是地址译码器相对比较复杂，而且IO端口常常会占用内存的一部分(当然一般的平台IO端口所需要的地址空间很少，比如<code>X86 IA32</code>平台也就是<code>64K</code>)。</p><h3 id="_3-2-独立编址" tabindex="-1">3.2 独立编址 <a class="header-anchor" href="#_3-2-独立编址" aria-hidden="true">#</a></h3><p>独立编址主要在<code>X86</code>平台中使用，主要是指<code>IO</code>与<code>存储器</code>分别有自己的地址总线，访问时相与不存在任何关系，这种方式最大的好处就是<code>IO</code>端口不占用存储器空间，但这种方式需要特殊的IO访问指令，比如<code>in</code>,<code>out</code>指令。</p><h2 id="_4-地址空间的划分" tabindex="-1">4. 地址空间的划分 <a class="header-anchor" href="#_4-地址空间的划分" aria-hidden="true">#</a></h2><p>地址空间的划分是指把整个空间划分为多个区域，每个区域对应一个设备。</p><h3 id="_4-1-通过硬连线来划分" tabindex="-1">4.1 通过硬连线来划分 <a class="header-anchor" href="#_4-1-通过硬连线来划分" aria-hidden="true">#</a></h3><p>这种方式在一般简单的嵌入式系统中经常使用，也就是存储器设备会连接到不同的地址总线上或片选信号线上（本质上片选信号线也是一种地址表示形式),这样就从硬件上决定了各个设备的基址就是不同的。典型的案例就是三星嵌入式处理器<code>S3C2440</code>平台，存储器区域分为8个<code>bank</code>,每个bank基址不同，详细的可以参考<code>S3C2440</code>手册。</p><h3 id="_4-2-通过软件来划分" tabindex="-1">4.2 通过软件来划分 <a class="header-anchor" href="#_4-2-通过软件来划分" aria-hidden="true">#</a></h3><p>这种方式就是在系统启动初期会形成地址映射表,地址映射表决定的地址的接收设备，典型的就是<code>X86</code>平台。在<code>X86</code>平台会有一个<code>北桥芯片</code>，<code>CPU</code>所有的地址访问，都会通过<code>前端总线</code>发送给<code>北桥芯片</code>,<code>北桥芯片</code>再通过<code>地址映射表</code>决定地址转发给<code>显卡</code>，<code>内存</code>还是<code>PCI</code>。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>这里地址映射表不是内核中的虚拟地址映射表，它仅仅存在于<code>北桥芯片</code>芯片中，一般由BOIS生成。</p></div><h2 id="_5-小结" tabindex="-1">5. 小结 <a class="header-anchor" href="#_5-小结" aria-hidden="true">#</a></h2><p>本文从宏观的角度讨论了计算机系统的地址空间基本原理，当然每一个具体的芯片可能有它自己对地址空间的规划，具体参考芯片手册。</p><hr><div class="tip custom-block"><p class="custom-block-title">提示</p><p>欢迎评论、探讨,如果发现错误请指正。转载请注明出处！ <a href="http://www.tsz.wiki" target="_blank" rel="noreferrer">探索者</a></p></div><hr>',17)),i(c,{title:n.$title},null,8,["title"])])}const V=h(Q,[["render",x]]);export{v as __pageData,V as default};
