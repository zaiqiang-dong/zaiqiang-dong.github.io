import{_ as e,r as l,o as p,c as i,a as r,b as t}from"./app.a2daf185.js";const F=JSON.parse('{"title":"概述","description":"","frontmatter":{},"headers":[{"level":2,"title":"1.什么是内存屏障","slug":"_1-什么是内存屏障","link":"#_1-什么是内存屏障","children":[]},{"level":2,"title":"2.为什么需要内存屏障","slug":"_2-为什么需要内存屏障","link":"#_2-为什么需要内存屏障","children":[{"level":3,"title":"2.1 什么是顺序一致性","slug":"_2-1-什么是顺序一致性","link":"#_2-1-什么是顺序一致性","children":[]},{"level":3,"title":"2.2 为什么会不一致","slug":"_2-2-为什么会不一致","link":"#_2-2-为什么会不一致","children":[]}]},{"level":2,"title":"3.通过内存屏障来解决一致性问题","slug":"_3-通过内存屏障来解决一致性问题","link":"#_3-通过内存屏障来解决一致性问题","children":[]},{"level":2,"title":"4.缓存一致性是否需要内存屏障来解决","slug":"_4-缓存一致性是否需要内存屏障来解决","link":"#_4-缓存一致性是否需要内存屏障来解决","children":[]}],"relativePath":"linux/parallel/barriers/overview/overview.md"}'),o={name:"linux/parallel/barriers/overview/overview.md"};function c(n,s,d,u,b,h){const a=l("Vssue");return p(),i("div",null,[s[0]||(s[0]=r(`<h1 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-hidden="true">#</a></h1><p><em>理想很丰满，现实很骨感，你的程序也一样，不一定会按照你的预期走</em></p><h2 id="_1-什么是内存屏障" tabindex="-1">1.什么是内存屏障 <a class="header-anchor" href="#_1-什么是内存屏障" aria-hidden="true">#</a></h2><p>是确保某些指令一定要在另外一些指令之前执行的一种机制，本质上讲是一条指令。</p><blockquote><p>从软件的角度讲内存屏障和内存没有什么直接的关系，它仅仅是叫内存屏障。</p></blockquote><h2 id="_2-为什么需要内存屏障" tabindex="-1">2.为什么需要内存屏障 <a class="header-anchor" href="#_2-为什么需要内存屏障" aria-hidden="true">#</a></h2><p>主要是为了解决指令顺序一致性问题。</p><h3 id="_2-1-什么是顺序一致性" tabindex="-1">2.1 什么是顺序一致性 <a class="header-anchor" href="#_2-1-什么是顺序一致性" aria-hidden="true">#</a></h3><p>软件的顺序分为两种</p><ol><li>软件编写时顺序</li><li>软件执行时顺序</li></ol><p>所谓顺序一致就是指软件的两种顺序要一致，也就是程序的执行和程序编写者的预期是一致的。</p><h3 id="_2-2-为什么会不一致" tabindex="-1">2.2 为什么会不一致 <a class="header-anchor" href="#_2-2-为什么会不一致" aria-hidden="true">#</a></h3><p>原因主要是如下三个：</p><ul><li><p>编译器原因</p><p>编译器在编译时，会对代码进行编译优化，从而提高代码执行效率，这个时候就可能会改变代码的执行顺序。也就是所谓的基于依赖的优化。</p></li><li><p>代码乱序执行</p><p>现代CPU多具备多发射，乱序执行等功能，主要是提高效率，但这必然会有一致性的问题产生。</p></li><li><p>多处理器同步</p><p>在多CPU的系统中，当一个CPU在进行读写操作时，可能有其他的CPU会进行读写操作，就可能会出现不一致的问题。</p></li></ul><h2 id="_3-通过内存屏障来解决一致性问题" tabindex="-1">3.通过内存屏障来解决一致性问题 <a class="header-anchor" href="#_3-通过内存屏障来解决一致性问题" aria-hidden="true">#</a></h2><p>内存屏障简单来讲就是一条CPU指令，每个平台上实现不一样，在ARM架构实现如下：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">#define isb()		asm volatile(&quot;isb&quot; : : : &quot;memory&quot;)</span></span>
<span class="line"><span style="color:#F8F8F2;">#define dmb(opt)	asm volatile(&quot;dmb &quot; #opt : : : &quot;memory&quot;)</span></span>
<span class="line"><span style="color:#F8F8F2;">#define dsb(opt)	asm volatile(&quot;dsb &quot; #opt : : : &quot;memory&quot;)</span></span>
<span class="line"><span style="color:#F8F8F2;"></span></span>
<span class="line"><span style="color:#F8F8F2;">#define mb()		dsb(sy)</span></span>
<span class="line"><span style="color:#F8F8F2;">#define rmb()		dsb(ld)</span></span>
<span class="line"><span style="color:#F8F8F2;">#define wmb()		dsb(st)</span></span>
<span class="line"><span style="color:#F8F8F2;"></span></span>
<span class="line"><span style="color:#F8F8F2;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如何使用，通过伪代码来展示</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">foo(){</span></span>
<span class="line"><span style="color:#F8F8F2;">	Instruction-1;</span></span>
<span class="line"><span style="color:#F8F8F2;">	mb();</span></span>
<span class="line"><span style="color:#F8F8F2;">    Instruction-2</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#F8F8F2;"></span></span>
<span class="line"><span style="color:#F8F8F2;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上面的伪代码中，可以确保Instruction-2在Instruction-1之后执行。</p><h2 id="_4-缓存一致性是否需要内存屏障来解决" tabindex="-1">4.缓存一致性是否需要内存屏障来解决 <a class="header-anchor" href="#_4-缓存一致性是否需要内存屏障来解决" aria-hidden="true">#</a></h2><p>缓存一致性是指多CPU系统中，一个CPU对某个地址内容修改过后，要保证另外一个CPU访问这个地址后，拿到的值是最新的。 但是这个需要内存一致性来解决吗？答案是不需要，这个是由硬件通过协议来完成的，不需要软件的任何参于。</p>`,22)),t(a,{title:n.$title},null,8,["title"])])}const _=e(o,[["render",c]]);export{F as __pageData,_ as default};
