import{_ as n,r as l,o as t,c as o,a as c,b as p}from"./app.a2daf185.js";const r="/assets/gccMakeCmake_02.1447480f.png",y=JSON.parse('{"title":"GCC、MAKE和CMAKE","description":"","frontmatter":{},"headers":[{"level":2,"title":"1、GCC、MAKE和CMAKE的关系","slug":"_1、gcc、make和cmake的关系","link":"#_1、gcc、make和cmake的关系","children":[]},{"level":2,"title":"2、GCC","slug":"_2、gcc","link":"#_2、gcc","children":[]},{"level":2,"title":"3、MAKE","slug":"_3、make","link":"#_3、make","children":[]},{"level":2,"title":"4、CMAKE","slug":"_4、cmake","link":"#_4、cmake","children":[]}],"relativePath":"tools/builder/common/gccMakeCmake/gccMakeCmake.md"}'),i={name:"tools/builder/common/gccMakeCmake/gccMakeCmake.md"};function F(s,a,m,k,d,h){const e=l("Vssue");return t(),o("div",null,[a[0]||(a[0]=c('<h1 id="gcc、make和cmake" tabindex="-1">GCC、MAKE和CMAKE <a class="header-anchor" href="#gcc、make和cmake" aria-hidden="true">#</a></h1><hr><table><thead><tr><th>软件版本</th><th>硬件版本</th><th>更新内容</th></tr></thead><tbody><tr><td></td><td></td><td>首次编写</td></tr></tbody></table><hr><h2 id="_1、gcc、make和cmake的关系" tabindex="-1">1、GCC、MAKE和CMAKE的关系 <a class="header-anchor" href="#_1、gcc、make和cmake的关系" aria-hidden="true">#</a></h2><p><img src="'+r+`" alt="关系图" title="关系图"></p><p><strong>说明:</strong></p><ol><li>cmake会根据Cmakelist.txt生成makefile文件</li><li>make会解析Makefile从而生成一条条的gcc编译指令</li><li>make调用gcc生成目标文件</li></ol><p>整个编译任务由三者共同协作来完成，下面具体介绍一下这三个工具，从而说明为什么需要三个工具才能完成整个编译任务。</p><h2 id="_2、gcc" tabindex="-1">2、GCC <a class="header-anchor" href="#_2、gcc" aria-hidden="true">#</a></h2><p><a href="https://www.gnu.org/software/gcc/" target="_blank" rel="noreferrer">GCC</a>是众多<strong>GNU</strong>自由软件中的一个，是一支持C/C++、Object-c、Go等很多的编程语言的编译器。GCC本质上一个编译套件，包括编译过程中各个功能模块，如ar、ld等等。也就是GCC是包括编译前端和后端的编译套件。</p><p>当我们的项目很小，只有一个或者几个文件时，直接可以通过GCC来完成编译工作：</p><div class="language-c line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">gcc [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">c</span><span style="color:#F92672;">|-</span><span style="color:#F8F8F2;">S</span><span style="color:#F92672;">|-</span><span style="color:#F8F8F2;">E] [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">std</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">standard]</span></span>
<span class="line"><span style="color:#F8F8F2;">    [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">g] [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">pg] [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">Olevel]</span></span>
<span class="line"><span style="color:#F8F8F2;">    [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">Wwarn...] [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">Wpedantic]</span></span>
<span class="line"><span style="color:#F8F8F2;">    [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">Idir...] [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">Ldir...]</span></span>
<span class="line"><span style="color:#F8F8F2;">    [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">Dmacro[</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">defn]...] [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">Umacro]</span></span>
<span class="line"><span style="color:#F8F8F2;">    [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">foption...] [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">mmachine</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">option...]</span></span>
<span class="line"><span style="color:#F8F8F2;">    [</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;">o outfile] [@file] infile...</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>最后的infile就是我们的源文件，但是当项目很大时,我们的源文件很多时，也就是意味着需要在infile那个文件输入大量的源文件名，而且这个源文件其中一些可能是生成一些库，这样就会需要多条gcc指令来完成，后期如果有新的源文件加入时也需要同时变化编译指令,如果修改了一个源文件，也需要全编译整个项目，这显然是不方便的，在这个背景下出现了make工具。</p><h2 id="_3、make" tabindex="-1">3、MAKE <a class="header-anchor" href="#_3、make" aria-hidden="true">#</a></h2><p><a href="https://www.gnu.org/software/make/" target="_blank" rel="noreferrer">MAKE</a>同样属于<strong>GNU</strong>自由软件，它工作的本质是根据Makefile的信息来调用gcc执行编译工作，也就是说在我们的项目中我们只写好Makefile文件就可以轻松实现编译工作，而且后期如果加入新的源文件，也只需要在Makefile加入就可以了，源文件发生修改，make也只会找与发生修改的文件相关的模块进行编译，而不会编译整个项目，而且我们在Makefile中还可以加入很多类似清理编译生成的.o文件的伪目标。</p><p>make帮助我们解决了gcc的调用问题，但是它仍然存在如下两个问题：</p><ol><li>Makefile的编写比较繁琐</li><li>Makefile在跨平台时需要重新编写</li></ol><p>为了解决上面的两个问题,cmake的出现了。</p><h2 id="_4、cmake" tabindex="-1">4、CMAKE <a class="header-anchor" href="#_4、cmake" aria-hidden="true">#</a></h2><p><a href="https://www.cmake.org" target="_blank" rel="noreferrer">CMAKE</a>是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个库。是由美国国家医学图书馆出资开发的开源软件，遵循BSD许可。 cmake会根据Cmakelist.txt文件生成Makefile文件，之后我们就可以调用make来编译整个项目。而且Cmakelist.txt的编写相对比较简单。</p><p>这里你可能会问为什么GNU组织没有开发相应的开源软件来解决make的上述两个问题？回答是GNU组织也开发相应的软件叫autotools,其实是一个工具集包括autoscan、autoconf等一系列的工具，由于工具太多，步骤和配置繁琐，后期被cmake替代了，在github上有一些相对老的软件依然是使用autotools来实现编译的。一般软件开发者会通过autoconf来生成configure,而我们在使用的时候，只需要执行./configure就可以生成相应的Makefile文件，再make就可以了。</p><hr><div class="tip custom-block"><p class="custom-block-title">提示</p><p>欢迎评论、探讨,如果发现错误请指正。转载请注明出处！ <a href="http://www.tsz.wiki" target="_blank" rel="noreferrer">探索者</a></p></div><hr>`,25)),p(e,{title:s.$title},null,8,["title"])])}const u=n(i,[["render",F]]);export{y as __pageData,u as default};
