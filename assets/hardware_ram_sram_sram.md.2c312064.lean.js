import{_ as r,r as d,o as h,c as i,a as l,b as n}from"./app.a2daf185.js";const b=JSON.parse('{"title":"缓存","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[{"level":3,"title":"1.1 缓存种类","slug":"_1-1-缓存种类","link":"#_1-1-缓存种类","children":[]},{"level":3,"title":"1.2 缓存一致性","slug":"_1-2-缓存一致性","link":"#_1-2-缓存一致性","children":[]},{"level":3,"title":"1.3 缓存访问速度","slug":"_1-3-缓存访问速度","link":"#_1-3-缓存访问速度","children":[]},{"level":3,"title":"2. 缓存与内存的关联关系","slug":"_2-缓存与内存的关联关系","link":"#_2-缓存与内存的关联关系","children":[]},{"level":3,"title":"3 相联性能问题","slug":"_3-相联性能问题","link":"#_3-相联性能问题","children":[]},{"level":3,"title":"4. 附录","slug":"_4-附录","link":"#_4-附录","children":[]}]}],"relativePath":"hardware/ram/sram/sram.md"}'),s={name:"hardware/ram/sram/sram.md"};function c(t,e,o,p,_,L){const a=d("Vssue");return h(),i("div",null,[e[0]||(e[0]=l('<h1 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-hidden="true">#</a></h1><hr><table><thead><tr><th>软件版本</th><th>硬件版本</th><th>更新内容</th></tr></thead><tbody><tr><td>linux 5.8.18</td><td>arm64</td><td></td></tr></tbody></table><hr><h2 id="_1-概述" tabindex="-1">1. 概述 <a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a></h2><p>硬件结构图</p><p>缓存部分，还会细分为一级cache,可以表示为<strong>L1</strong>，二级cache表示为<strong>L2</strong>,依次类推。其中一级cache还分为数据cache,指令cache，所以可以<strong>L1d</strong>表示一级数据cache,还有<strong>L1i</strong>表示一级指令cache等等。</p><h3 id="_1-1-缓存种类" tabindex="-1">1.1 缓存种类 <a class="header-anchor" href="#_1-1-缓存种类" aria-hidden="true">#</a></h3><p>独占缓存是指L1，L2，L3级所缓存的内容不相同，这样当L1需要缓存新的内容，必须先在L1中腾出空间，腾出的内容将放L2中，L2中需要腾出空间，腾出的见容放到L3中，L3也需要腾出空间，腾出的内容将推入内存中，从L1到内存逐级推入的成本会越来越高，也就是从L1腾出空间，腾出的内容放到L2中要比L3腾出空间腾出内容放入内存成本要低很多。</p><p>包容性缓存是指L1的内容同时也会存在于L2中，因为L2的空间比L1大，所以L2除了L1中的内容还会有别的内容，L3和L2的关系也是一样。</p><p>对比：</p><ul><li>缓存新内容：独占缓存需要从L1推入L2比较慢，而包容性缓存不需要因为L2中已经包括了L1的内容</li><li>空间浪费：独占缓存不存在浪费，包容性缓存因为L1和L2中存在相同的内容所以存在浪费</li><li>缓存新内容速度：独占缓存只需要放L1就可以了，而包容性需要同时放入L2,所以比较慢</li></ul><h3 id="_1-2-缓存一致性" tabindex="-1">1.2 缓存一致性 <a class="header-anchor" href="#_1-2-缓存一致性" aria-hidden="true">#</a></h3><p>这个是由缓存一致性协义来保证的，也就是MESI协议。</p><h3 id="_1-3-缓存访问速度" tabindex="-1">1.3 缓存访问速度 <a class="header-anchor" href="#_1-3-缓存访问速度" aria-hidden="true">#</a></h3><p>使用CPU周期来作为时间单位，在Pentium M机器上的访问速度如下：</p><table><thead><tr><th>地址</th><th>同期数</th></tr></thead><tbody><tr><td>寄存器</td><td>小于1个周期</td></tr><tr><td>L1</td><td>大约3个周期</td></tr><tr><td>L2</td><td>大约14个周期</td></tr><tr><td>内存</td><td>大约240个周期</td></tr></tbody></table><p>::: Tip 访问时间大部分是浪费在线路延迟，电信号的传播其实达不到光速，要想减少线路延迟需要提高工艺，比如从14nm到7nm. :::</p><p>上表的数据看起来比较大，实际情况不会那样糟糕，原因是不是经常都不命中，而是程序的局部性原因导致大部分情况可以在L1命中。另外由于指令流水线的存在，一条指令的执行会被分解，那样一些操作如从缓存或者内存中加载数据，可以是和其他的执行过程并发进行，所以也不会加载内存数据的开销会被部分隐藏。对于写操作cpu也不会等待数据真正的进入缓存或者内存，它可能会直接将数据放入store buff这样存储器中。</p><h3 id="_2-缓存与内存的关联关系" tabindex="-1">2. 缓存与内存的关联关系 <a class="header-anchor" href="#_2-缓存与内存的关联关系" aria-hidden="true">#</a></h3><h4 id="_2-1-全相联" tabindex="-1">2.1 全相联 <a class="header-anchor" href="#_2-1-全相联" aria-hidden="true">#</a></h4><p>这种映射下，一个地址中，S部分是没有的，只有T部分和O部分。对于一个缓存行为64字节，缓存大小为4M的缓存，那么就会有65536个缓存行，仅仅通过T位的比较来确定那个缓存行，还要保证在几个cpu周期内比较完成取出数据对于硬件实现是比较困难的，如果使用直接比较器所需的晶体管数据是很大的，如果使用迭代比较器又不能满足速度的要求。所以这种映射只适合用于小容量的缓存上。 对于 L1i、L1d 和更高级别的缓存，需要采用不同的方法。能做的就是限制搜索。在最极端的限制中，每个标签都映射到一个缓存条目。计算很简单：给定具有 65,536 个条目的 4MB/64B 缓存，我们可以使用地址的第 6 位到第 21 位（16 位）直接寻址每个条目。低 6 位是缓存行的索引。</p><h4 id="_2-2-直接映射" tabindex="-1">2.2 直接映射 <a class="header-anchor" href="#_2-2-直接映射" aria-hidden="true">#</a></h4><p>这种直接映射缓存速度快且相对容易实现。它只需要一个比较器、一个多路复用器（在此图中有两个，标签和数据是分开的，但这不是设计的硬性要求），以及一些仅选择有效缓存行内容的逻辑。由于速度要求，比较器很复杂，但现在只有一个；因此，可以花更多的精力让它变快。这种方法的真正复杂性在于多路复用器。简单多路复用器中的晶体管数量随 O(log N) 增长，其中 N 是高速缓存行的数量。这是可以容忍的，但可能会变慢，在这种情况下，可以通过在多路复用器中的晶体管上花费更多空间来并行化一些工作并提高速度，从而提高速度。 随着高速缓存大小的增加，晶体管的总数会缓慢增长，这使得该解决方案非常有吸引力。 但它有一个缺点：只有当程序使用的地址相对于用于直接映射的位均匀分布时，它才能很好地工作。如果不是（通常是这种情况），一些缓存条目会被大量使用，因此会被反复驱逐，而其他缓存条目几乎不会被使用或保持为空。</p><h4 id="_2-3-组相联" tabindex="-1">2.3 组相联 <a class="header-anchor" href="#_2-3-组相联" aria-hidden="true">#</a></h4><p>这个可以解决直接相联的缺点，这个问题可以通过使缓存集关联来解决。标签和数据存储被分成由地址选择的集合。这类似于直接映射缓存。但是缓存中的每个设置值不是只有一个元素，而是为相同的设置值缓存少量值。并行比较所有集合成员的标签，这类似于全关联缓存的功能。</p><h3 id="_3-相联性能问题" tabindex="-1">3 相联性能问题 <a class="header-anchor" href="#_3-相联性能问题" aria-hidden="true">#</a></h3><p>关于相联的性能需要很细的分析和研究，这里我们一言以蔽之就是相联的方式，组相联中分多少个set，一个set中多少个way,还有每个way也就是一个cache line的大小都影响最终的性能，具体可以查引用部分的文档。</p><h3 id="_4-附录" tabindex="-1">4. 附录 <a class="header-anchor" href="#_4-附录" aria-hidden="true">#</a></h3><p><a href="https://lwn.net/Articles/252125/" target="_blank" rel="noreferrer">CPU caches</a></p><hr><div class="tip custom-block"><p class="custom-block-title">提示</p><p>欢迎评论、探讨,如果发现错误请指正。转载请注明出处！ <a href="http://www.tsz.wiki" target="_blank" rel="noreferrer">探索者</a></p></div><hr>',33)),n(a,{title:t.$title},null,8,["title"])])}const f=r(s,[["render",c]]);export{b as __pageData,f as default};
